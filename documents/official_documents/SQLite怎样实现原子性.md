<h1>SQLite怎么实现原子性</h1>
###1.0 简介
事务性数据库一个重要的性质就是原子性. 原子性意味着同一个事务内的操作, 要么全部生效, 要么全部不生效. 在保证原子性的情况下, 对数据库文件的不同修改就好像能够"同时发生"一样. 实际上, 硬件在处理多个写入操作时, 是将它们序列化完成的, 并不是"同时发生". 但是SQLite实现了原子性, 使得这些操作在逻辑上能够被视为"同时发生".

SQLite在处理事务时, 即使遇到了诸如系统崩溃甚至是突然断电的这种情况, 也能维持其原子性. 

本文就描述SQLite怎么实现的原子性. 

本文描述的技术只是SQLite在"rollback mode"下所使用的, 而在另一种模式, "WAL mode"下使用的技术则不同. 关于"WAL mode"下的技术, 请看[write-ahead log documentation](http://www.sqlite.org/wal.html).

<br><br>

###2.0 对硬件的假设
我们假设硬盘写入的最小单位为"区(sector)". 诸如只修改部分区的内容的操作, 是不被允许的. 如果你真的只想要修改区上部分内容, 你也得读出整个区的内容, 然后做出修改, 再整个写回到硬盘.

在传统硬盘中, "区"的限制是同时针对读和写操作的. 而在闪存中, 读的最小单位通常比写的最小单位小得多. SQLite只考虑对写入操作的最小单位限制, 本文中所说的"区", 都只针对写操作.

在SQLite3.3.14版本之前, 区的大小都被设置为512bytes. 虽然你可以修改代码来扩大这个值, 但是我们并没有对更大的区值进行测试. 用512bytes作为默认值是有原因的, 因为大多数硬盘都在内部使用512bytes作为一个扇区大小. 但是最近以4096bytes作为扇区大小的硬盘越来越多, 所以SQLite中区的限制也应该增大. 从SQLite3.3.14起, 我们在OS层中增加了一个函数用来查找操作系统的扇区大小. 但是现在这个函数依旧返回的只是一个512bytes的固定值, 因为我们没有发现一个统一的方法, 能够同时在unix和windows下查询到扇区大小. 但是你能够为你的设备复写这个函数, 以选取一个最合适的"区值".

SQLite假设对区的写操作不是原子性的. 并且SQLite假设它是线性的. 线性的意思是我们假设操作系统从区的一头开始, 按照bytes的顺序逐一写入. 开始的位置可以是区两头中的任意一头. 如果在写入的过程中发生了断电等情况, 那么这个区的一部分内容就会出现问题. SQLite另一个重要假设是, 如果出现了这种情况, 那么区的两头结尾的两个byte的值, 一定有一个被改变了. 所以我们预想操作系统不会从区的中间开始写数据, 虽然不知道是不是所有操作系统都满足我们的假设, 但是我们看来这样假设是合理的.

上一段说了我们并不假设磁盘写入是原子性的. 在SQLite3.5.0后, 我们抽象出了一层新结构, 虚拟文件系统VFS(virtual file system). 只有通过VFS, SQLite才能和操作系统打交道. 在新的VFS接口中, 有一个叫xDeviceCharacteristic的函数. 这个函数会询问操作系统, 看它是否满足某些性质. 如果操作系统的区写入操作是原子性的, 这个函数将能发现, 此时SQLite应该利用这一性质进行优化. 但是在实际中, 不管是unix还是windows, 其区写入操作都不是原子性的, 所以这项优化也被我们直接忽略了. 

SQLite假设操作系统会有写入缓冲, 并且在写入完成时, 缓冲区的内容不一定被写入到了硬盘盘中. 进一步的, SQLite假设操作系统会对写入操作重排序. 因此, SQLite会执行"flush"和"fsync"操作, 且假设这两个操作只有当硬盘同步结束后, 才会返回. 然而在某些版本的windows和unix上, flush和fsync操作是无用的. 这增大了SQLite出现错误的可能性. 对于这种情况, 我们也无能为力. 

SQLite假设随着数据库文件的增大, 新增加的空间包含原来的信息, 这些信息被当作垃圾, 随后, 这些垃圾信息将被新写入的信息覆盖. 换句话说, SQLite假设先增加文件的大小, 后修改其内容. 这是一个悲观的假设, 因此SQLite需要做额外的工作, 来保证数据库不会出现错误, 比如当操作系统修改了文件大小, 却还未修改其内容, 然后出现断电时. xDeviceCharacteristics函数会检查操作系统是否是先修改文件内容再修改文件大小. (这个性质在代码中被设置为SQLITE_IOCAP_SAFE_APPEND.) 当xDeviceCharacteristics 检测到操作系统确实是先修改文件内容, 在修改文件大小时, SQLite就可以略去一些多余的操作, 以此来增加硬盘I/O速率. 然而在实际的实现中, 不管是对windows还是unix, 我们都没做出这样的乐观假设.

SQLite假设从进程的角度来看, 删除文件是原子性的. 这意味着, 如果SQLite请求删除操作, 而此时断电了, 那么电力恢复时, 那个文件要么被全部删除了, 要么毫无影响. SQLite假设不会出现文件出现"被部分删除"的情况. 

SQLite假设bit反转的情况由各种物理原因, 以及操作系统bug等因素造成, 这应该是操作系统以及底层硬件的责任. 因此SQLite不会对这些情况做任何检测和处理.

默认的, SQLite假设当通过系统调用在对文件的某个区间进行写操作时, 不会对这个区间外的其他信息有任何影响, 即使是出现了系统崩溃或者断电等情况. 我们称之为[powersafe overwrite](http://www.sqlite.org/psow.html). 在3.7.9版本前, SQLite并没有做出这种乐观假设. 但是随着硬盘的标准扇区从512bytes扩大到了4096bytes, 我们需要做出这个乐观假设, 来提高I/O速率. 但是这个假设可以在编译甚至运行时期给去除, 详细请看[powersafe overwrite](http://www.sqlite.org/psow.html).

<br><br>
###3.0 单文件提交
我们先看看SQLite怎么对单文件实现原子性. 关于实现原子性中, 所用到的日志文件, 其细节将在之后介绍.

###3.1 初始状态
当数据库连接被第一次打开时, 整个系统的状态如下图. 最右边代表被存储在硬盘上的数据, 每个矩形就是一个区. 蓝色代表这个区包含了数据库文件. 中间是操作系统的缓冲区. 在下图中, 其白色表示当前缓冲区是空的. 而最左边则是用户空间(即用户进程可以直接操作的空间). 此时数据库连接刚被打开, 什么操作都还未被执行.
![](http://www.sqlite.org/images/ac/commit-0.gif)

###3.2 申请读取锁
在写数据之前, 你必须先读出数据并对其做出修改. 即使是插入数据, SQLite也得先读取sqlite_master表中的内容, 并由此来解释INSERT语句, 并决定将数据存储在哪个地方.

读取数据库文件的第一步是申请一把shared锁. "shared"锁允许多个数据库连接同时读取一个数据库文件. 同时shared锁也会阻止其他连接对数据库文件进行修改, 因为现在正有连接在读取数据库文件内容. 这个性质很重要, 因为如果你在读取的同时, 另外一个地方却在对数据库文件进行修改, 那么你读取出的内容, 可能包含一部分被修改, 一部分未被修改的内容. 这会使写入操作丢失原子性.

值得注意的是, shared锁被加在了系统缓冲区上, 而不是硬盘文件上. 因为文件锁只是操作系统维护在内存空间中的一点信息而已. 因此, 如果系统出现故障, 这把锁或许会消失. 
![](http://www.sqlite.org/images/ac/commit-1.gif)

###3.3 从数据库文件中读取数据
当shared锁申请完成后, 我们开始读入数据. 在这个场景中, 数据必须先从硬盘到操作系统缓冲区, 再到用户空间. 在多次读入中, 某些数据或许能直接在操作系统缓冲区找到, 此时就不必再从硬盘中拷贝数据.

通常情况下, 只有部分页会被读入到用户空间. 在这个例子中, 只有3页内容被我们读入. 通常情况下, 一份数据库文件含有上千页数据, 而平时只有少量数据会被读入到用户空间中.
![](http://www.sqlite.org/images/ac/commit-2.gif)

###3.4 取得reserved锁
修改数据库前, SQLite必须先取得reserved锁. reserved锁和shared锁都运行进程从数据库文件中读取数据. 一个reserved锁能和多个shared锁共存. 但是一个数据库文件上只能有一把reserved锁. 因此同一时刻能只能有一个进程能尝试对数据库文件进行写入.

reserved锁的含义是, 表示当前进程准备在不久后对数据库文件进行修改和写入操作. 因为修改和写入暂时并未执行, 因此其他进程还能继续读取数据库, 但是其他进程不能尝试对数据库进行修改和写入.
![](http://www.sqlite.org/images/ac/commit-3.gif)

###3.5 创建rollback journal文件
在修改数据库文件前, SQLite先会创建一个rollback journal文件, 并将原内容写入到这个文件中. rollback journal文件用来保存回滚事务时需要用到的所有信息. 

rollback journal文件包含了一个文件头(下图绿色部分), 其中记录了原数据的大小. 所以即使我们修改了文件的大小, 也能从rollback journal文件中得知修改前的大小. 被修改页的页号也被记录在这个文件中. 

建立新文件时, 多数的操作系统都不好向硬盘中写入任何数据. 新的文件暂时只是被创建于操作系统的缓冲区中. 只有当稍后操作系统有空闲时, 才会把新文件写入到硬盘. 对用户来说, I/O操作会比实际写入到硬盘中快. 在下图中, 硬盘下的rollback journal对应部分为白色, 我们以此来表示这种情况.
![](http://www.sqlite.org/images/ac/commit-4.gif)

###3.6 修改用户空间的数据
当原始内容被存入到rollback journal文件后, 用户空间中的数据将被修改. 每个数据库连接都有自己的用户空间, 所以这个修改只对该连接自己有效. 其他数据库连接还只能看到未被修改的数据. 所以当该连接进行修改时, 其他连接还能读取数据库内容. 
![](http://www.sqlite.org/images/ac/commit-5.gif)

###3.7 刷新rollback journal到硬盘
下一步是将rollback journal的内容写入到硬盘中. 这是关键的一步, 这一步保证数据库能处理一些极端情况, 比如断电. 这一步会花费不少时间, 因为硬盘IO向来是比较慢的.

这一步通常比你想的"简单的刷新rollback journal文件到硬盘"要复杂. 主流的操作系统中, 需要分两步进行"刷新"(或者说"同步"). 第一步是刷新rollback journal的主要内容(蓝色部分), 接下来修改rollback journal的文件头部分, 然后刷新文件头到硬盘. 这样做的原因及一些细节将会在之后的几节解释.
![](http://www.sqlite.org/images/ac/commit-6.gif)

###3.8 取得exclusive锁
在写回数据到数据库文件之前, 我们必须得到exclusive锁. 取得exclusive锁的过程分两步. 第一步是取得pending, 接着将pengding锁转化为exclusive.

pending锁运行之前已经申请shared锁的进程继续读取内容. 但是不运行新申请shared锁. pengding锁的目的是为了防止写入操作被饿死, 比如一直有新进程申请读取数据库, 写操作被一直等待. 当所有的shared锁都被释放后, pending锁将被转化为exclusive锁.
![](http://www.sqlite.org/images/ac/commit-7.gif)

###3.9 写回数据
取得exclusive锁后, 以为着已经没有其他进程在读取这份文件了, 我们可以安全的向里面写入数据了. 同样的, 由于操作系统缓冲区的存在, 被写回的内容不会被直接更新到硬盘, 而只是更新到了操作系统缓冲区. 
![](http://www.sqlite.org/images/ac/commit-8.gif)

###3.10 刷新数据到硬盘
我们将在此时再进行一次刷新(上次刷新是将journal文件刷新到硬盘), 将操作系统缓冲区上对数据库的修改的内容刷新到硬盘. 这是至关重要的一步操作. 同样的, 由于硬盘I/O速度缓慢, 这一步和3.7一样耗时.
![](http://www.sqlite.org/images/ac/commit-9.gif)

###3.11 删除rollback journal
当数据库的修改内容被刷新到硬盘后, rollback journal文件就可以被删除了. 这步删除操作将在事务被提交完成后立即执行. 如果在删除之前发生了断电, 那么恢复程序(之后会介绍)会根据rollback journal回滚之前的事务. 如果断电发生在删除文件之后, 那么恢复程序不会对之前事务进行回滚. 所以SQLite对事务的回滚, 其实是根据是否存在rollback journal文件决定的.

删除一个文件其实并不是原子操作, 但是对于用户进程来说, 它可以被当作原子操作. 进程可以对操作系统询问"这个文件存在么?", 而且得到的答案只能是"NO"或者"YES". 同样的, 即使在断电重启后, 得到的答案也只能是这两个, 如果是"YES", 那么进行回滚, 如果是"NO", 则反之.

事务的回滚决定与是否存在journal文件, 而文件的删除被进程当作原子操作, 因此从进程的角度来看, 事务的提交也会是原子性的.

其实对于大多数操作系统, 删除文件的代价是巨大的, 因此作为优化, SQLite能被设置为"将journal文件的文件头写成0"或者"使用truncate将文件大小设置为0", 这两种方式, 来代替删除文件. "使用truncate设置文件大小为0", 也如同"删除文件"一样, 被视为原子性的."将journal的文件头写成0"虽然不是原子性的, 但是在进行回滚前, 会对journal文件头进行验证, 如果有任何错误, 回滚将不会发生.
![](http://www.sqlite.org/images/ac/commit-A.gif)

###3.12 释放锁
最后一步是释放exclusive锁, 使得其他进程能重新访问这份数据库文件.

如下图, 可以发现释放锁后, 用户空间的内容已经被情况, 但是在比较新版本的SQLite中, 用户空间中的内容能够被再保存一段时间, 以应付下一次事务操作, 这比再重新从硬盘中读出数据, 显然快的多. 但是在使用上次事务遗留数据时, 我们第一步操作依然是要取得一个shared锁, 因为此时可能有其他进程正在修改数据库文件. 同时每个数据库文件的文件头中, 都有一个计数器, 表示当前数据库文件被修改过的次数. 如果我们发现此时这个计数器和我们之前存的不一样, 那么说明已经有进程修改过数据库了. 那么这是我们将情况用户空间, 重读入数据.
![](http://www.sqlite.org/images/ac/commit-B.gif)